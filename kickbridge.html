<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kick & Streamer.bot Bridge</title>
    <script src="https://js.pusher.com/8.3.0/pusher.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 50%, #0f0f0f 100%);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        
        .header .subtitle {
            color: #888;
            font-size: 1.1rem;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            padding: 20px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .status-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .status-connected .status-dot {
            background: #4aff4a;
            box-shadow: 0 0 10px rgba(74, 255, 74, 0.5);
        }
        
        .status-disconnected .status-dot {
            background: #ff4a4a;
            box-shadow: 0 0 10px rgba(255, 74, 74, 0.5);
        }
        
        .status-connecting .status-dot {
            background: #ffaa4a;
            box-shadow: 0 0 10px rgba(255, 170, 74, 0.5);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .logs-container {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        
        .logs-header {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .logs-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
        }
        
        .logs-controls {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }
        
        .btn-clear {
            background: #ff4757;
            color: white;
        }
        
        .btn-clear:hover {
            background: #ff3742;
        }
        
        .btn-pause {
            background: #ffa502;
            color: white;
        }
        
        .btn-pause:hover {
            background: #ff9500;
        }
        
        #messages {
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.6;
            scrollbar-width: thin;
            scrollbar-color: #444 #222;
        }
        
        #messages::-webkit-scrollbar {
            width: 8px;
        }
        
        #messages::-webkit-scrollbar-track {
            background: #222;
        }
        
        #messages::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        
        #messages::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 8px 12px;
            border-radius: 6px;
            border-left: 4px solid transparent;
            background: rgba(255, 255, 255, 0.02);
            transition: all 0.2s ease;
        }
        
        .log-entry:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .log-info {
            color: #74b9ff;
            border-left-color: #74b9ff;
        }
        
        .log-success {
            color: #00b894;
            border-left-color: #00b894;
            background: rgba(0, 184, 148, 0.1);
        }
        
        .log-error {
            color: #e17055;
            border-left-color: #e17055;
            background: rgba(225, 112, 85, 0.1);
        }
        
        .log-warning {
            color: #fdcb6e;
            border-left-color: #fdcb6e;
            background: rgba(253, 203, 110, 0.1);
        }
        
        .log-reward {
            color: #fd79a8;
            border-left-color: #fd79a8;
            background: rgba(253, 121, 168, 0.1);
            font-weight: 600;
        }
        
        .log-chat {
            color: #81ecec;
            border-left-color: #81ecec;
        }
        
        .log-connection {
            color: #a29bfe;
            border-left-color: #a29bfe;
        }
        
        .log-timestamp {
            color: #636e72;
            font-size: 11px;
            margin-right: 8px;
        }
        
        .log-category {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-right: 8px;
            text-transform: uppercase;
        }
        
        .category-kick {
            background: #ff6b6b;
            color: white;
        }
        
        .category-sb {
            background: #4ecdc4;
            color: white;
        }
        
        .category-system {
            background: #45b7d1;
            color: white;
        }
        
        .category-kick::before {
            content: "";
            background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15V7h2v4l4-4h3l-4 4 4 4h-3l-4-4v4h-2z" fill="%23ffffff"/></svg>');
            background-size: 14px 14px;
            background-repeat: no-repeat;
            background-position: center;
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            filter: drop-shadow(0 0 2px rgba(255,255,255,0.8));
            border-radius: 2px;
            background-color: rgba(255,255,255,0.1);
        }
        
        .category-sb::before {
            content: "";
            background-image: url('https://streamer.bot/logo.svg');
            background-size: 14px 14px;
            background-repeat: no-repeat;
            background-position: center;
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            filter: brightness(0) invert(1) drop-shadow(0 0 2px rgba(255,255,255,0.8));
            border-radius: 2px;
            background-color: rgba(255,255,255,0.1);
        }
        
        .category-system::before {
            content: "‚öôÔ∏è";
            margin-right: 4px;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0f0f0f; color: #e0e0e0; min-height: 100vh; padding: 0; margin: 0; }
        .hidden { display: none !important; }
        .center-error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0; left: 0;
            z-index: 9999;
            background: rgba(15,15,15,0.97);
        }
        .error-box {
            background: #ff3b3b;
            color: #fff;
            padding: 2em 2.5em;
            border-radius: 14px;
            font-size: 1.3em;
            font-weight: bold;
            box-shadow: 0 4px 32px rgba(0,0,0,0.25);
            text-align: center;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <div id="error-container" class="center-error hidden">
        <div id="error-box" class="error-box"></div>
    </div>
    <script>
        // --- Settings Loader ---
        function getQueryParam(name) {
            const url = new URL(window.location.href);
            return url.searchParams.get(name);
        }
        function getSetting(name) {
            // Prefer query param, fallback to localStorage
            const qp = getQueryParam(name);
            if (qp) return qp;
            const settings = JSON.parse(localStorage.getItem('kickBridgeSettings') || '{}');
            if (name === 'chatroom_id') return settings.chatroomId;
            if (name === 'sb_ip') return settings.sbIp;
            if (name === 'sb_port') return settings.sbPort;
            return undefined;
        }
        const chatroomId = getSetting('chatroom_id');
        const sbIp = getSetting('sb_ip');
        const sbPort = getSetting('sb_port');
        if (!chatroomId || !sbIp || !sbPort) {
            // Show nothing if any setting is missing
            document.body.innerHTML = '';
        } else {
            // Hide all UI by default
            function showError(message) {
                document.getElementById('error-box').textContent = message;
                document.getElementById('error-container').classList.remove('hidden');
            }
            function hideError() {
                document.getElementById('error-container').classList.add('hidden');
            }
            // --- Bridge code below (Account 1 only) ---
            const KICK_PUSHER_KEY = "32cbd69e4b950bf97679";
            const KICK_PUSHER_CLUSTER = "us2";
            const ACCOUNT = {
                id: 1,
                name: "KickUser",
                chatroomId: chatroomId,
                streamerId: chatroomId, // fallback, can be improved if needed
                channels: {
                    chatroom_v2: `chatrooms.${chatroomId}.v2`,
                    chatroom: `chatroom_${chatroomId}`,
                    chatrooms: `chatrooms.${chatroomId}`
                }
            };
            const SB_WEBSOCKET_IP = sbIp;
            const SB_WEBSOCKET_PORT = sbPort;
            const SB_WEBSOCKET_ENDPOINT = "/";
            const SB_ACTION_NAME_ON_CHAT = "YourChatActionName";
            const SB_ACTION_NAME_ON_FOLLOW = "YourFollowActionName"; // Replace with the SB action name for follows (if needed)
            // Add more action names for other events as needed

            const messagesDiv = document.getElementById('messages');

            let sbSocket = null;
            let loggingPaused = false;
            let pendingRequests = new Map(); // Track pending requests for error handling
            // Auth tokens removed - using public channels only

            // Auth management removed - using public channels only

            function logEvent(message, type = 'info', category = 'system') {
                if (
                    type === 'error' &&
                    (message.toLowerCase().includes('streamer.bot') ||
                     message.toLowerCase().includes('sb') ||
                     category === 'sb' ||
                     message.toLowerCase().includes('websocket'))
                ) {
                    showError('Cannot connect to Streamer.bot');
                } else if (
                    type === 'error' &&
                    (message.toLowerCase().includes('kick') || category === 'kick')
                ) {
                    showError('Cannot connect to Kick');
                }
                // Do not display any other UI
            }
            
            function toggleLogging() {
                loggingPaused = !loggingPaused;
                const btn = document.querySelector('.btn-pause');
                btn.textContent = loggingPaused ? 'Resume' : 'Pause';
                btn.style.background = loggingPaused ? '#00b894' : '#ffa502';
                
                if (!loggingPaused) {
                    logEvent('üìù Logging resumed', 'info', 'system');
                }
            }
            
            function clearLogs() {
                messagesDiv.innerHTML = '';
                logEvent('üóëÔ∏è Logs cleared', 'info', 'system');
            }
            
            // --- Streamer.bot WebSocket Connection ---
            function connectStreamerBot() {
                const wsUrl = `ws://${SB_WEBSOCKET_IP}:${SB_WEBSOCKET_PORT}${SB_WEBSOCKET_ENDPOINT}`;
                console.log(`%c[Streamer.bot]%c üîó Connecting to: %c${wsUrl}`, 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#4ecdc4;font-weight:bold;', 'color:#fff;');
                logEvent(`üîó Connecting to Streamer.bot at ${wsUrl}`, 'connection', 'sb');
                try {
                    sbSocket = new WebSocket(wsUrl);

                    sbSocket.onopen = () => {
                        console.log('%c[Streamer.bot]%c ‚úÖ Connected successfully', 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#00e676;font-weight:bold;');
                        hideError();
                        logEvent("‚úÖ Streamer.bot connected successfully", 'success', 'sb');
                    };

                    sbSocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            console.log('%c[Streamer.bot]%c üì© Message:', 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;', data);
                        } catch (e) {
                            console.log('%c[Streamer.bot]%c üì© Raw message:', 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;', event.data);
                        }
                    };

                    sbSocket.onerror = (error) => {
                        console.error('%c[Streamer.bot]%c ‚ùå Connection error:', 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#ff6b6b;font-weight:bold;', error);
                        logEvent(`‚ùå Connection error: ${error.message || 'WebSocket error'}`, 'error', 'sb');
                    };

                    sbSocket.onclose = (event) => {
                        const reason = event.code === 1006 ? 'Connection refused' : `Code ${event.code}`;
                        console.warn(`%c[Streamer.bot]%c üîå Disconnected (${reason}). Retrying in 5s...`, 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#ffa502;font-weight:bold;');
                        logEvent(`üîå Disconnected (${reason}). Retrying in 5s...`, 'warning', 'sb');
                        sbSocket = null;
                        setTimeout(connectStreamerBot, 5000);
                    };
                } catch (error) {
                    console.error('%c[Streamer.bot]%c ‚ùå Failed to create connection:', 'color:#fff;background:#4ecdc4;padding:2px 6px;border-radius:4px;', 'color:#ff6b6b;font-weight:bold;', error);
                    logEvent(`‚ùå Failed to create connection: ${error.message}`, 'error', 'sb');
                    setTimeout(connectStreamerBot, 5000);
                }
            }

            function sendToStreamerBot(actionName, args = {}) {
                if (sbSocket && sbSocket.readyState === WebSocket.OPEN) {
                    const requestId = `kick-${Date.now()}`;
                    const request = {
                        "request": "DoAction",
                        "action": {
                            "name": actionName
                        },
                        "args": args,
                        "id": requestId
                    };
                    
                    // Store the request for error handling
                    pendingRequests.set(requestId, {
                        actionName: actionName,
                        timestamp: Date.now()
                    });
                    
                    const argKeys = Object.keys(args);
                    const argSummary = argKeys.length > 0 ? ` (${argKeys.join(', ')})` : '';
                    logEvent(`üöÄ Executing action: <strong>${actionName}</strong>${argSummary}`, 'success', 'sb');
                    
                    sbSocket.send(JSON.stringify(request));
                } else {
                    logEvent("‚ö†Ô∏è Cannot execute action: Not connected", 'warning', 'sb');
                }
            }

            // --- Kick Pusher Connection ---
            console.log('%c[Kick]%c üîå Initializing Kick connection...', 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#45b7d1;font-weight:bold;');
            logEvent("üîå Initializing Kick connection...", 'connection', 'kick');
            const pusher = new Pusher(KICK_PUSHER_KEY, {
                cluster: KICK_PUSHER_CLUSTER,
                forceTLS: true
            });

            pusher.connection.bind('state_change', (states) => {
                const icons = {
                    'connected': '‚úÖ',
                    'connecting': 'üîÑ',
                    'disconnected': '‚ùå',
                    'unavailable': '‚ö†Ô∏è'
                };
                const statusMap = {
                    'connected': 'connected',
                    'connecting': 'connecting',
                    'disconnected': 'disconnected',
                    'unavailable': 'disconnected'
                };
                console.log(`%c[Kick]%c ${icons[states.current] || 'üì°'} Connection ${states.current}`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#45b7d1;font-weight:bold;');
                logEvent(`${icons[states.current] || 'üì°'} Connection ${states.current}`, 'connection', 'kick');
            });

            pusher.connection.bind('error', (err) => {
                const errorMsg = err.error?.data?.message || err.error?.message || 'Unknown error';
                console.error('%c[Kick]%c ‚ùå Connection error:', 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#ff6b6b;font-weight:bold;', errorMsg);
                logEvent(`‚ùå Connection error: ${errorMsg}`, 'error', 'kick');
            });

            // Subscribe to channels for the single account
            const account = ACCOUNT;
            if (account.chatroomId === "YOUR_SECOND_CHATROOM_ID" || !account.chatroomId) {
                logEvent(`‚è≠Ô∏è Skipping ${account.name} - configuration needed`, 'warning', 'kick');
            } else {
                console.log(`%c[Kick]%c üì∫ Setting up ${account.name} channels`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;');
                // Subscribe to chatroom_v2
                const chatroomV2Sub = pusher.subscribe(account.channels.chatroom_v2);
                chatroomV2Sub.bind_global((eventName, data) => {
                    if (shouldLogEvent(eventName)) {
                        console.log(`%c[Kick]%c üì° [${account.name}] ${eventName}`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;', data);
                        logEvent(`üì° [${account.name}] ${eventName}`, 'info', 'kick');
                    }
                });
                // Subscribe to chatroom (no v2)
                const chatroomSub = pusher.subscribe(account.channels.chatroom);
                chatroomSub.bind_global((eventName, data) => {
                    if (shouldLogEvent(eventName)) {
                        console.log(`%c[Kick]%c üì° [${account.name}] ${eventName}`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;', data);
                        logEvent(`üì° [${account.name}] ${eventName}`, 'info', 'kick');
                    }
                });
                // Subscribe to chatrooms
                const chatroomsSub = pusher.subscribe(account.channels.chatrooms);
                chatroomsSub.bind_global((eventName, data) => {
                    if (shouldLogEvent(eventName)) {
                        console.log(`%c[Kick]%c üì° [${account.name}] ${eventName}`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#b2f7ef;font-weight:bold;', data);
                        logEvent(`üì° [${account.name}] ${eventName}`, 'info', 'kick');
                    }
                });
                // Store subscriptions
                const subscriptions = [{
                    account: account,
                    chatroomV2: chatroomV2Sub,
                    chatroom: chatroomSub,
                    chatrooms: chatroomsSub
                }];
                // Add event handlers for the single account
                subscriptions.forEach(sub => {
                    const account = sub.account;
                    // Reward handlers
                    sub.chatroom.bind('RewardRedeemedEvent', (data) => {
                        console.log(`%c[Kick]%c üéÅ [${account.name}] RewardRedeemedEvent`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#fd79a8;font-weight:bold;', data);
                        handleRewardRedemption(account, data);
                    });
                    sub.chatrooms.bind('RewardRedeemedEvent', (data) => {
                        console.log(`%c[Kick]%c üéÅ [${account.name}] RewardRedeemedEvent`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#fd79a8;font-weight:bold;', data);
                        handleRewardRedemption(account, data);
                    });
                    // Chat message handlers
                    sub.chatroomV2.bind('App\\Events\\ChatMessageSentEvent', (data) => {
                        console.log(`%c[Kick]%c üí¨ [${account.name}] ChatMessageSentEvent`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#81ecec;font-weight:bold;', data);
                        handleChatMessage(account, data);
                    });
                    // Subscription status handlers
                    sub.chatroom.bind('pusher:subscription_succeeded', () => {
                        console.log(`%c[Kick]%c ‚úÖ [${account.name}] Chatroom connected`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#00e676;font-weight:bold;');
                        logEvent(`‚úÖ [${account.name}] Chatroom connected`, 'success', 'kick');
                    });
                    sub.chatroom.bind('pusher:subscription_error', (status) => {
                        console.error(`%c[Kick]%c ‚ùå [${account.name}] Chatroom connection failed`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#ff6b6b;font-weight:bold;', status);
                        logEvent(`‚ùå [${account.name}] Chatroom connection failed: ${JSON.stringify(status)}`, 'error', 'kick');
                    });
                    sub.chatroomV2.bind('pusher:subscription_succeeded', () => {
                        console.log(`%c[Kick]%c ‚úÖ [${account.name}] Chatroom V2 connected`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#00e676;font-weight:bold;');
                        logEvent(`‚úÖ [${account.name}] Chatroom V2 connected`, 'success', 'kick');
                    });
                    sub.chatroomV2.bind('pusher:subscription_error', (status) => {
                        console.error(`%c[Kick]%c ‚ùå [${account.name}] Chatroom V2 connection failed`, 'color:#fff;background:#45b7d1;padding:2px 6px;border-radius:4px;', 'color:#ff6b6b;font-weight:bold;', status);
                        logEvent(`‚ùå [${account.name}] Chatroom V2 connection failed`, 'error', 'kick');
                    });
                });
            }
            
            function shouldLogEvent(eventName) {
                const importantEvents = ['ChatMessage', 'Reward', 'Follow', 'Subscribe', 'Gift', 'Raid', 'Host'];
                return importantEvents.some(event => eventName.includes(event));
            }

            // Reward redemption handler function
            function handleRewardRedemption(account, data) {
                let rewardData = null;

                // Handle data whether it's a string or already an object
                if (typeof data === 'string') {
                    try {
                        rewardData = JSON.parse(data);
                    } catch (e) {
                        logEvent(`‚ùå [${account.name}] Failed to parse reward data`, 'error');
                        return;
                    }
                } else if (typeof data === 'object' && data !== null) {
                     rewardData = data;
                } else {
                    logEvent(`‚ùå [${account.name}] Invalid reward data type`, 'error');
                    return;
                }

                if (!rewardData || typeof rewardData !== 'object') {
                     logEvent(`‚ùå [${account.name}] Invalid reward object`, 'error');
                     return;
                }

                const rewardTitle = rewardData.reward_title;
                const username = rewardData.username;
                const userInput = rewardData.user_input;

                const displayInput = userInput ? ` with input: "<em>${userInput}</em>"` : '';
                logEvent(`üéÅ [${account.name}] <strong>${username}</strong> redeemed <strong>${rewardTitle}</strong>${displayInput}`, 'reward', 'kick');

                // Prepare args for Streamer.bot
                const args = {
                    kickRewardTitle: rewardTitle.trim(),
                    kickUsername: username,
                    kickUserInput: rewardData.user_input,
                    kickUserId: rewardData.user_id,
                    kickChannelId: rewardData.channel_id,
                    kickAccount: account.name,
                    kickAccountId: account.id
                };

                // Construct the action name dynamically based on the reward title (trim whitespace)
                const actionName = `KickReward-${rewardTitle.trim()}`;

                // Trigger the specific Streamer.bot action by name
                sendToStreamerBot(actionName, args);
            }
            
            // Chat message handler function
            function handleChatMessage(account, data) {
                const username = data.user.username;
                const message = data.message.message;
                
                logEvent(`üí¨ [${account.name}] <strong>${username}</strong>: ${message}`, 'chat');

                const args = {
                    kickUsername: username,
                    kickMessage: message,
                    kickUserId: data.user.id,
                    kickAccount: account.name,
                    kickAccountId: account.id,
                    isSubscribed: data.user.is_subscribed,
                    monthsSubscribed: data.user.months_subscribed,
                    badges: data.user.follower_badges?.join(', ') || ''
                };

                // Use shared action name for both accounts
                const actionName = SB_ACTION_NAME_ON_CHAT;
                sendToStreamerBot(actionName, args);
            }

            // All channel subscriptions now handled in the loop above

            // Using public channels only - no private channel authentication needed
            logEvent('üì° Using public channels only for event monitoring', 'info', 'kick');

            // --- Initial Connection ---
            logEvent('üöÄ Starting bridge initialization...', 'info', 'system');
            connectStreamerBot();
            
            // Initialize logging
            logEvent('üìù Event logging system ready', 'success', 'system');
            logEvent('üîß Bridge ready for Kick events', 'success', 'system');
        }
    </script>
</body>
</html>