<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kick Bridge | ICHRISIRL</title>
    <script src="https://js.pusher.com/8.3.0/pusher.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .status-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: auto;
            height: auto;
            display: flex;
            align-items: flex-start;
            justify-content: flex-end;
            z-index: 9999;
            background: transparent;
            transition: opacity 0.3s ease;
        }
        
        .status-message {
            background: rgba(30, 35, 40, 0.85);
            border: 1px solid rgba(58, 65, 72, 0.6);
            border-radius: 12px;
            padding: 1rem 1.25rem;
            text-align: left;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            max-width: 280px;
            backdrop-filter: blur(10px);
            transform: translateX(320px);
            animation: slideInRight 0.3s ease-out forwards;
        }
        
        .status-icon {
            width: 20px;
            height: 20px;
            margin-right: 0.75rem;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            flex-shrink: 0;
        }
        
        .status-connecting .status-icon {
            background: rgba(52, 152, 219, 0.2);
            animation: pulse 2s infinite;
        }
        
        .status-error .status-icon {
            background: rgba(231, 76, 60, 0.2);
        }
        
        .status-success .status-icon {
            background: rgba(39, 174, 96, 0.2);
        }
        
        .status-content {
            display: flex;
            align-items: center;
        }
        
        .status-text {
            color: #ffffff;
            font-size: 0.875rem;
            font-weight: 600;
            margin: 0;
            line-height: 1.2;
        }
        
        .status-subtitle {
            color: #a0a8b8;
            font-size: 0.75rem;
            font-weight: 400;
            margin: 0.25rem 0 0 0;
            line-height: 1.2;
        }
        
        .status-details {
            display: none;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3); }
            50% { transform: scale(1.1); box-shadow: 0 8px 40px rgba(52, 152, 219, 0.5); }
            100% { transform: scale(1); box-shadow: 0 4px 20px rgba(52, 152, 219, 0.3); }
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(320px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div id="status-overlay" class="status-overlay" style="display: none;">
        <div class="status-message">
            <div class="status-content">
                <div class="status-icon" id="status-icon">‚ö†Ô∏è</div>
                <div>
                    <div class="status-text" id="status-text">Not Connected</div>
                    <div class="status-subtitle" id="status-subtitle">Bridge is offline</div>
                </div>
            </div>
            <div class="status-details" id="status-details"></div>
        </div>
    </div>
<script>
    // Enhanced console logging with beautiful formatting
    const log = {
        timestamp: () => new Date().toLocaleTimeString(),
        
        info: (category, message, data = null) => {
            console.log(
                `%cüîµ ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #74b9ff; font-weight: bold;',
                'color: #00b894; background: rgba(0,184,148,0.1); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #e0e0e0;',
                data ? data : ''
            );
        },
        
        success: (category, message, data = null) => {
            console.log(
                `%c‚úÖ ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #00b894; font-weight: bold;',
                'color: #00b894; background: rgba(0,184,148,0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #00b894; font-weight: 600;',
                data ? data : ''
            );
        },
        
        error: (category, message, data = null) => {
            console.log(
                `%c‚ùå ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #e17055; font-weight: bold;',
                'color: #e17055; background: rgba(225,112,85,0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #e17055; font-weight: 600;',
                data ? data : ''
            );
        },
        
        warning: (category, message, data = null) => {
            console.log(
                `%c‚ö†Ô∏è ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #fdcb6e; font-weight: bold;',
                'color: #fdcb6e; background: rgba(253,203,110,0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #fdcb6e; font-weight: 600;',
                data ? data : ''
            );
        },
        
        reward: (category, message, data = null) => {
            console.log(
                `%cüéÅ ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #fd79a8; font-weight: bold;',
                'color: #fd79a8; background: rgba(253,121,168,0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #fd79a8; font-weight: 700;',
                data ? data : ''
            );
        },
        
        connection: (category, message, data = null) => {
            console.log(
                `%cüîó ${log.timestamp()} %c[${category}] %c${message}`,
                'color: #a29bfe; font-weight: bold;',
                'color: #a29bfe; background: rgba(162,155,254,0.2); padding: 2px 6px; border-radius: 4px; font-weight: 600;',
                'color: #a29bfe; font-weight: 600;',
                data ? data : ''
            );
        }
    };

    function showStatus(msg, type = 'error', details = '') {
        const overlay = document.getElementById('status-overlay');
        const textEl = document.getElementById('status-text');
        const subtitleEl = document.getElementById('status-subtitle');
        const detailsEl = document.getElementById('status-details');
        const iconEl = document.getElementById('status-icon');
        const messageEl = overlay.querySelector('.status-message');
        
        textEl.textContent = msg;
        detailsEl.textContent = details;
        
        // Remove existing type classes
        messageEl.classList.remove('status-connecting', 'status-error', 'status-success');
        
        if (type === 'connecting') {
            messageEl.classList.add('status-connecting');
            subtitleEl.textContent = 'Establishing connection...';
            iconEl.textContent = 'üîÑ';
            detailsEl.textContent = details || 'Please wait while we connect to services';
        } else if (type === 'success') {
            messageEl.classList.add('status-success');
            subtitleEl.textContent = 'All systems operational';
            iconEl.textContent = '‚úÖ';
            setTimeout(() => hideStatus(), 2000);
        } else {
            messageEl.classList.add('status-error');
            subtitleEl.textContent = 'Connection failed';
            iconEl.textContent = '‚ö†Ô∏è';
            detailsEl.textContent = details || 'Check your settings and try refreshing the page';
        }
        
        overlay.style.display = 'flex';
        log.warning('SYSTEM', `Status: ${msg}`);
    }
    
    function hideStatus() {
        const overlay = document.getElementById('status-overlay');
        // Show success state briefly before hiding
        showStatus('Connected!', 'success', 'Bridge is now fully operational');
        
        setTimeout(() => {
            overlay.style.display = 'none';
            log.success('SYSTEM', 'üåü Bridge fully connected and operational!');
            log.info('SYSTEM', '‚úì Kick rewards will now trigger Streamer.bot actions');
        }, 2000);
    }
    function getQueryParam(name) {
        const url = new URL(window.location.href);
        return url.searchParams.get(name);
    }
    function getSetting(name) {
        const qp = getQueryParam(name);
        if (qp) return qp;
        const settings = JSON.parse(localStorage.getItem('kickBridgeSettings') || '{}');
        if (name === 'chatroom_id') return settings.chatroomId;
        if (name === 'sb_ip') return settings.sbIp;
        if (name === 'sb_port') return settings.sbPort;
        return undefined;
    }
    log.info('SYSTEM', 'üöÄ Kick Bridge initialized');

    const chatroomId = getQueryParam('chatroomid');
    const channelId = getQueryParam('channelid');
    const sbIp = getQueryParam('sbip') || '127.0.0.1';
    const sbPort = getQueryParam('sbport') || '8080';

    log.info('CONFIG', `Chatroom ID: ${chatroomId || 'Not set'}`);
    log.info('CONFIG', `Channel ID: ${channelId || 'Not set'}`);
    log.info('CONFIG', `Streamer.bot: ${sbIp}:${sbPort}`);
    
    if (!chatroomId || !sbIp || !sbPort) {
        log.error('CONFIG', 'Missing required settings - bridge cannot start');
        showStatus('Configuration Error', 'error', 'Missing chatroom ID, IP, or port settings');
    } else {
        let kickConnected = false;
        let sbConnected = false;
        function updateStatus() {
            if (!kickConnected && !sbConnected) {
                showStatus('Services Offline', 'error', 'Unable to connect to Kick and Streamer.bot');
            } else if (!kickConnected) {
                showStatus('Kick Offline', 'error', 'Connected to Streamer.bot but not Kick chat');
            } else if (!sbConnected) {
                showStatus('Streamer.bot Offline', 'error', 'Connected to Kick but not Streamer.bot');
            } else {
                hideStatus();
            }
        }
        const KICK_PUSHER_KEY = "32cbd69e4b950bf97679";
        const KICK_PUSHER_CLUSTER = "us2";
        const ACCOUNT = {
            id: 1,
            name: "KickUser",
            chatroomId: chatroomId,
            streamerId: chatroomId,
            channelId: channelId,
            channels: {
                chatroomv2: `chatrooms.${chatroomId}.v2`,
                chatroom: `chatroom_${chatroomId}`,
                chatrooms: `chatrooms_${chatroomId}`,
                channel: channelId ? `channel_${channelId}` : null
            }
        };
        const SB_WEBSOCKET_IP = sbIp;
        const SB_WEBSOCKET_PORT = sbPort;
        const SB_WEBSOCKET_ENDPOINT = "/";
        let sbSocket = null;
        let rewardPrefix = getQueryParam('rewardprefix') || 'KickReward-';
        rewardPrefix = rewardPrefix.replace(/_/g, '-');
        if (!rewardPrefix.endsWith('-')) rewardPrefix += '-';
        
        log.info('CONFIG', `Reward prefix: "${rewardPrefix}"`);
        log.info('SYSTEM', 'Starting connection to services...');
        function connectStreamerBot() {
            const wsUrl = `ws://${SB_WEBSOCKET_IP}:${SB_WEBSOCKET_PORT}${SB_WEBSOCKET_ENDPOINT}`;
            log.connection('STREAMER.BOT', `Connecting to: ${wsUrl}`);
            
            try {
                sbSocket = new WebSocket(wsUrl);
                
                sbSocket.onopen = () => {
                    log.success('STREAMER.BOT', 'WebSocket connection established');
                    sbConnected = true;
                    updateStatus();
                };
                
                sbSocket.onerror = (e) => {
                    log.error('STREAMER.BOT', 'WebSocket connection failed', e);
                    sbConnected = false;
                    updateStatus();
                };
                
                sbSocket.onclose = (e) => {
                    log.warning('STREAMER.BOT', `WebSocket disconnected (Code: ${e.code})`, e.reason);
                    sbConnected = false;
                    updateStatus();
                    setTimeout(() => {
                        log.info('STREAMER.BOT', 'Attempting reconnection in 5 seconds...');
                        connectStreamerBot();
                    }, 5000);
                };
                
            } catch (error) {
                log.error('STREAMER.BOT', 'Failed to create WebSocket connection', error);
                sbConnected = false;
                updateStatus();
                setTimeout(() => {
                    log.info('STREAMER.BOT', 'Retrying connection in 5 seconds...');
                    connectStreamerBot();
                }, 5000);
            }
        }
        const pusher = new Pusher(KICK_PUSHER_KEY, {
            cluster: KICK_PUSHER_CLUSTER,
            forceTLS: true
        });
        // Subscribe to all relevant chatroom channels to verify actual chatroom connection
        let chatroomSubs = [];
        let chatroomSuccess = 0;
        let chatroomFail = 0;
        function updateKickConnected() {
            if (chatroomSuccess > 0) {
                kickConnected = true;
            } else {
                kickConnected = false;
            }
            updateStatus();
        }
        function bindChatroomSub(channelName) {
            const ch = pusher.subscribe(channelName);
            chatroomSubs.push(ch);
            
            ch.bind('pusher:subscription_succeeded', () => {
                log.success('KICK', `Subscribed to channel: ${channelName}`);
                chatroomSuccess++;
                updateKickConnected();
            });
            
            ch.bind('pusher:subscription_error', () => {
                log.error('KICK', `Subscription failed for channel: ${channelName}`);
                chatroomFail++;
                updateKickConnected();
            });
        }
        bindChatroomSub(ACCOUNT.channels.chatroomv2);
        bindChatroomSub(ACCOUNT.channels.chatroom);
        bindChatroomSub(ACCOUNT.channels.chatrooms);

        // Subscribe to channel for KicksGifted events if channelId is available
        if (ACCOUNT.channels.channel) {
            bindChatroomSub(ACCOUNT.channels.channel);
        }
        pusher.connection.bind('state_change', (states) => {
            log.info('KICK', `Pusher connection state: ${states.previous} ‚Üí ${states.current}`);
            
            if (states.current !== 'connected') {
                kickConnected = false;
                updateStatus();
            }
        });
        
        pusher.connection.bind('error', (err) => {
            log.error('KICK', 'Pusher connection error', err);
            kickConnected = false;
            updateStatus();
        });
        updateStatus();
        connectStreamerBot();

        function handleRewardRedemption(data) {
            let rewardData = null;

            if (typeof data === 'string') {
                try {
                    rewardData = JSON.parse(data);
                } catch (e) {
                    log.error('KICK', 'Failed to parse reward data', data);
                    return;
                }
            } else if (typeof data === 'object' && data !== null) {
                rewardData = data;
            } else {
                return;
            }

            if (!rewardData || typeof rewardData !== 'object') return;

            let rewardTitle = rewardData.reward_title || '';
            rewardTitle = rewardTitle.trim().replace(/^[-]+/, '');

            const username = rewardData.username;
            const userInput = rewardData.user_input;

            log.reward('KICK', `üéÅ Reward "${rewardTitle}" redeemed by ${username}`, {
                title: rewardTitle,
                user: username,
                input: userInput,
                userId: rewardData.user_id
            });

            const args = {
                kickRewardTitle: rewardTitle,
                kickUsername: username,
                kickUserInput: userInput,
                kickUserId: rewardData.user_id,
                kickChannelId: rewardData.channel_id
            };

            const actionName = `${rewardPrefix}${rewardTitle}`;

            if (sbSocket && sbSocket.readyState === WebSocket.OPEN) {
                log.success('STREAMER.BOT', `Triggering action: ${actionName}`, args);

                const request = {
                    request: "DoAction",
                    action: { name: actionName },
                    args: args,
                    id: `kick-${Date.now()}`
                };

                sbSocket.send(JSON.stringify(request));
            } else {
                log.error('STREAMER.BOT', 'Cannot send reward - WebSocket not connected');
                showStatus('Reward Failed', 'error', 'Streamer.bot connection lost - reward could not be sent');
            }
        }

        function handleKicksGifted(data) {
            let kickData = null;

            if (typeof data === 'string') {
                try {
                    kickData = JSON.parse(data);
                } catch (e) {
                    log.error('KICK', 'Failed to parse kicks gifted data', data);
                    return;
                }
            } else if (typeof data === 'object' && data !== null) {
                kickData = data;
            } else {
                return;
            }

            if (!kickData || typeof kickData !== 'object') return;

            const sender = kickData.sender || {};
            const gift = kickData.gift || {};
            const message = kickData.message || '';

            const username = sender.username || 'Unknown';
            const giftName = gift.name || 'Unknown Gift';
            const amount = gift.amount || 0;
            const giftType = gift.type || '';
            const tier = gift.tier || '';

            log.reward('KICK', `üéÅ Kicks Gifted: ${giftName} (${amount}) by ${username}`, {
                sender: sender,
                gift: gift,
                message: message
            });

            const args = {
                kickGiftName: giftName,
                kickGiftAmount: amount,
                kickGiftType: giftType,
                kickGiftTier: tier,
                kickUsername: username,
                kickUserId: sender.id,
                kickUserColor: sender.username_color,
                kickMessage: message,
                kickChannelId: channelId
            };

            // Create action name based on kick amount (without prefix for kicks)
            const actionName = `Kicks${amount}`;

            if (sbSocket && sbSocket.readyState === WebSocket.OPEN) {
                log.success('STREAMER.BOT', `Triggering action: ${actionName}`, args);

                const request = {
                    request: "DoAction",
                    action: { name: actionName },
                    args: args,
                    id: `kick-gifted-${Date.now()}`
                };

                sbSocket.send(JSON.stringify(request));
            } else {
                log.error('STREAMER.BOT', 'Cannot send kicks gifted - WebSocket not connected');
                showStatus('Kicks Gifted Failed', 'error', 'Streamer.bot connection lost - kicks gifted could not be sent');
            }
        }

        function handleRaidEvent(data) {
            let raidData = null;

            if (typeof data === 'string') {
                try {
                    raidData = JSON.parse(data);
                } catch (e) {
                    log.error('KICK', 'Failed to parse raid data', data);
                    return;
                }
            } else if (typeof data === 'object' && data !== null) {
                raidData = data;
            } else {
                return;
            }

            if (!raidData || typeof raidData !== 'object') return;

            const chatroomId = raidData.chatroom_id || 0;
            const optionalMessage = raidData.optional_message || '';
            const numberViewers = raidData.number_viewers || 0;
            const hostUsername = raidData.host_username || 'Unknown';

            log.reward('KICK', `üéØ Raid from ${hostUsername} with ${numberViewers} viewers`, {
                host: hostUsername,
                viewers: numberViewers,
                message: optionalMessage,
                chatroomId: chatroomId
            });

            const args = {
                kickHostUsername: hostUsername,
                kickHostViewerCount: numberViewers,
                kickHostMessage: optionalMessage,
                kickHostChatroomId: chatroomId
            };

            const actionName = 'KickHost';

            if (sbSocket && sbSocket.readyState === WebSocket.OPEN) {
                log.success('STREAMER.BOT', `Triggering action: ${actionName}`, args);

                const request = {
                    request: "DoAction",
                    action: { name: actionName },
                    args: args,
                    id: `kick-host-${Date.now()}`
                };

                sbSocket.send(JSON.stringify(request));
            } else {
                log.error('STREAMER.BOT', 'Cannot send host - WebSocket not connected');
                showStatus('Host Failed', 'error', 'Streamer.bot connection lost - host could not be sent');
            }
        }
        // Subscribe to reward events on all chatroom channels
        function bindRewardEvents(channel) {
            channel.bind('RewardRedeemedEvent', handleRewardRedemption);
            channel.bind('StreamHostEvent', handleRaidEvent);
        }
        chatroomSubs.forEach(bindRewardEvents);

        // Subscribe to KicksGifted events on the channel if available
        if (ACCOUNT.channels.channel) {
            const channelSub = pusher.subscribe(ACCOUNT.channels.channel);
            channelSub.bind('KicksGifted', handleKicksGifted);

            channelSub.bind('pusher:subscription_succeeded', () => {
                log.success('KICK', `Subscribed to KicksGifted events on channel: ${ACCOUNT.channels.channel}`);
            });

            channelSub.bind('pusher:subscription_error', () => {
                log.error('KICK', `Failed to subscribe to KicksGifted events on channel: ${ACCOUNT.channels.channel}`);
            });
        }
    }
</script>
</body>
</html>